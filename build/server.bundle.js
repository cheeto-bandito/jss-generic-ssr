'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}

const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter
function spread(args) {
    const attributes = Object.assign({}, ...args);
    let str = '';
    Object.keys(attributes).forEach(name => {
        if (invalid_attribute_name_character.test(name))
            return;
        const value = attributes[name];
        if (value === undefined)
            return;
        if (value === true)
            str += " " + name;
        const escaped = String(value)
            .replace(/"/g, '&#34;')
            .replace(/'/g, '&#39;');
        str += " " + name + "=" + JSON.stringify(escaped);
    });
    return str;
}
const escaped = {
    '"': '&quot;',
    "'": '&#39;',
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
function escape(html) {
    return String(html).replace(/["'&<>]/g, match => escaped[match]);
}
function each(items, fn) {
    let str = '';
    for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
    }
    return str;
}
const missing_component = {
    $$render: () => ''
};
function validate_component(component, name) {
    if (!component || !component.$$render) {
        if (name === 'svelte:component')
            name += ' this={...}';
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
    }
    return component;
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(parent_component ? parent_component.$$.context : []),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, options = {}) => {
            on_destroy = [];
            const result = { head: '', css: new Set() };
            const html = $$render(result, props, {}, options);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.head
            };
        },
        $$render
    };
}

/* public\index.html generated by Svelte v3.9.1 */

const Index = create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	return `<!doctype html>
	<html>

	<head>
	    <meta charset="utf8">
	    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	    <meta name="theme-color" content="#000000">

	    <title>Svelte app</title>

	    <link rel="icon" type="image/png" href="favicon.png">
	    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

	    <link rel="stylesheet" href="/global.css">
	    <link rel="stylesheet" href="/bundle.css">
	    <style id="__SVELTE_CSS__"></style>
	</head>

	<body>
	    <noscript>
	        You need to enable JavaScript to run this app.
	    </noscript>
	    <div id="root"></div>

	    <script type="application/json" id="__JSS_STATE__">null</script>
	    <script src="/bundle.js"></script>
	</body>

	</html>`;
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var dataApi = createCommonjsModule(function (module, exports) {
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var ResponseError = /** @class */ (function (_super) {
    __extends(ResponseError, _super);
    function ResponseError(message, response) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ResponseError.prototype);
        _this.response = response;
        return _this;
    }
    return ResponseError;
}(Error));
function checkStatus(response) {
    if (response.status >= 200 && response.status < 300) {
        return response;
    }
    var error = new ResponseError(response.statusText, response);
    throw error;
}
// note: encodeURIComponent is available via browser (window) or natively in node.js
// if you use another js engine for server-side rendering you may not have native encodeURIComponent
// and would then need to install a package for that functionality
function getQueryString(params) {
    return Object.keys(params)
        .map(function (k) { return encodeURIComponent(k) + "=" + encodeURIComponent(params[k]); })
        .join('&');
}
function fetchData(url, fetcher, params) {
    if (params === void 0) { params = {}; }
    var qs = getQueryString(params);
    var fetchUrl = url.indexOf('?') !== -1 ? url + "&" + qs : url + "?" + qs;
    return fetcher(fetchUrl)
        .then(checkStatus)
        .then(function (response) {
        // axios auto-parses JSON responses, don't need to JSON.parse
        return response.data;
    });
}
var resolveLayoutServiceUrl = function (options, verb) {
    if (options === void 0) { options = {}; }
    var _a = options.host, host = _a === void 0 ? '' : _a, _b = options.configurationName, configurationName = _b === void 0 ? 'jss' : _b, serviceUrl = options.serviceUrl;
    if (serviceUrl) {
        return serviceUrl;
    }
    return host + "/sitecore/api/layout/" + verb + "/" + configurationName;
};
/**
 * Makes a request to Sitecore Layout Service for the specified route item path.
 */
function fetchRouteData(itemPath, options) {
    var querystringParams = options.querystringParams, layoutServiceConfig = options.layoutServiceConfig;
    var fetchUrl = resolveLayoutServiceUrl(layoutServiceConfig, 'render');
    return fetchData(fetchUrl, options.fetcher, __assign({ item: itemPath }, querystringParams));
}
exports.fetchRouteData = fetchRouteData;
/**
 * Makes a request to Sitecore Layout Service for the specified placeholder in
 * a specific route item. Allows you to retrieve rendered data for individual placeholders instead of entire routes.
 */
function fetchPlaceholderData(placeholderName, itemPath, options) {
    var querystringParams = options.querystringParams, layoutServiceConfig = options.layoutServiceConfig;
    var fetchUrl = resolveLayoutServiceUrl(layoutServiceConfig, 'placeholder');
    return fetchData(fetchUrl, options.fetcher, __assign({ placeholderName: placeholderName, item: itemPath }, querystringParams));
}
exports.fetchPlaceholderData = fetchPlaceholderData;
});

unwrapExports(dataApi);
var dataApi_1 = dataApi.fetchRouteData;
var dataApi_2 = dataApi.fetchPlaceholderData;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
    reHasEscapedHtml = RegExp(reEscapedHtml.source);

/** Used to map HTML entities to characters. */
var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'",
  '&#96;': '`'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.unescape` to convert HTML entities to characters.
 *
 * @private
 * @param {string} chr The matched character to unescape.
 * @returns {string} Returns the unescaped character.
 */
var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * The inverse of `_.escape`; this method converts the HTML entities
 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
 * their corresponding characters.
 *
 * **Note:** No other HTML entities are unescaped. To unescape additional
 * HTML entities use a third-party library like [_he_](https://mths.be/he).
 *
 * @static
 * @memberOf _
 * @since 0.6.0
 * @category String
 * @param {string} [string=''] The string to unescape.
 * @returns {string} Returns the unescaped string.
 * @example
 *
 * _.unescape('fred, barney, &amp; pebbles');
 * // => 'fred, barney, & pebbles'
 */
function unescape$1(string) {
  string = toString(string);
  return (string && reHasEscapedHtml.test(string))
    ? string.replace(reEscapedHtml, unescapeHtmlChar)
    : string;
}

var lodash_unescape = unescape$1;

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
var requiresPort = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encodeURIComponent(key);
      value = encodeURIComponent(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
var stringify = querystringify;
var parse = querystring;

var querystringify_1 = {
	stringify: stringify,
	parse: parse
};

var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!requiresPort(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || querystringify_1.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!requiresPort(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString$1(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString$1 };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = querystringify_1;

var urlParse = Url;

var mediaApi = createCommonjsModule(function (module, exports) {
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// what is `import x = require('x');`? great question: https://github.com/Microsoft/TypeScript/issues/5073


// finds an img tag with HTML attributes
var imgTagRegex = /<img([^>]+)\/>/i;
// finds all the HTML attributes in a string
var htmlAttrsRegex = /([^=\s]+)(="([^"]*)")?/gi;
// finds the Sitecore media URL prefix
var mediaUrlPrefixRegex = /\/([-~]{1})\/media\//i;
/**
 * Makes a request to Sitecore Content Service for the specified item path.
 */
exports.findEditorImageTag = function (editorMarkup) {
    // match the tag
    var tagMatch = editorMarkup.match(imgTagRegex);
    if (!tagMatch || tagMatch.length < 2) {
        return null;
    }
    // find the attrs and turn them into a Map
    var attrs = {};
    var match = htmlAttrsRegex.exec(tagMatch[1]);
    while (match != null) {
        attrs[match[1]] = lodash_unescape(match[3]);
        match = htmlAttrsRegex.exec(tagMatch[1]);
    }
    return {
        imgTag: tagMatch[0],
        attrs: attrs,
    };
};
/**
 * Receives a Sitecore media URL and replaces `/~/media` or `/-/media` with `/~/jssmedia` or `/-/jssmedia`, respectively.
 * This replacement allows the JSS media handler to be used for JSS app assets.
 * Also, any provided `params` are used as the querystring parameters for the media URL.
 */
exports.updateImageUrl = function (url, params) {
    // polyfill node `global` in browser to workaround https://github.com/unshiftio/url-parse/issues/150
    if (typeof window !== 'undefined' && !window.global) {
        window.global = {};
    }
    var parsed = urlParse(url, {}, true);
    parsed.set('query', params || parsed.query);
    var match = mediaUrlPrefixRegex.exec(parsed.pathname);
    if (match && match.length > 1) {
        // regex will provide us with /-/ or /~/ type
        parsed.set('pathname', parsed.pathname.replace(mediaUrlPrefixRegex, "/" + match[1] + "/jssmedia/"));
    }
    return parsed.toString();
};
/**
 * Receives an array of `srcSet` parameters that are iterated and used as parameters to generate
 * a corresponding set of updated Sitecore media URLs via @see updateImageUrl. The result is a comma-delimited
 * list of media URLs with respective dimension parameters.
 *
 * @example
 * // returns '/ipsum.jpg?h=1000&w=1000 1000w, /ipsum.jpg?mh=250&mw=250 250w'
 * getSrcSet('/ipsum.jpg', [{ h: 1000, w: 1000 }, { mh: 250, mw: 250 } ])
 *
 * More information about `srcSet`: {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}
 */
exports.getSrcSet = function (url, srcSet, imageParams) {
    return srcSet
        .map(function (params) {
        var newParams = __assign({}, imageParams, params);
        var imageWidth = newParams.w || newParams.mw;
        if (!imageWidth) {
            return null;
        }
        return exports.updateImageUrl(url, newParams) + " " + imageWidth + "w";
    })
        .filter(function (value) { return value; })
        .join(', ');
};
});

unwrapExports(mediaApi);
var mediaApi_1 = mediaApi.findEditorImageTag;
var mediaApi_2 = mediaApi.updateImageUrl;
var mediaApi_3 = mediaApi.getSrcSet;

var util = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.isServer = function () { return !(typeof window !== 'undefined' && window.document); };
exports.isExperienceEditorActive = function () {
    if (exports.isServer()) {
        return false;
    }
    var sc = window.Sitecore;
    return Boolean(sc && sc.PageModes && sc.PageModes.ChromeManager);
};
exports.resetExperienceEditorChromes = function () {
    if (exports.isExperienceEditorActive()) {
        window.Sitecore.PageModes.ChromeManager.resetChromes();
    }
};
});

unwrapExports(util);
var util_1 = util.isServer;
var util_2 = util.isExperienceEditorActive;
var util_3 = util.resetExperienceEditorChromes;

var layoutDataUtils = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Safely extracts a field value from a rendering or fields object.
 * Null will be returned if the field is not defined.
 */
function getFieldValue(renderingOrFields, fieldName, defaultValue) {
    if (!renderingOrFields || !fieldName) {
        return defaultValue;
    }
    var fields = renderingOrFields;
    if (fields[fieldName] && typeof fields[fieldName].value !== 'undefined') {
        return fields[fieldName].value;
    }
    var rendering = renderingOrFields;
    if (!rendering.fields ||
        !rendering.fields[fieldName] ||
        typeof rendering.fields[fieldName].value === 'undefined') {
        return defaultValue;
    }
    return rendering.fields[fieldName].value;
}
exports.getFieldValue = getFieldValue;
/**
 * Gets rendering definitions in a given child placeholder under a current rendering.
 */
function getChildPlaceholder(rendering, placeholderName) {
    if (!rendering ||
        !placeholderName ||
        !rendering.placeholders ||
        !rendering.placeholders[placeholderName]) {
        return [];
    }
    return rendering.placeholders[placeholderName];
}
exports.getChildPlaceholder = getChildPlaceholder;
});

unwrapExports(layoutDataUtils);
var layoutDataUtils_1 = layoutDataUtils.getFieldValue;
var layoutDataUtils_2 = layoutDataUtils.getChildPlaceholder;

var dist = createCommonjsModule(function (module, exports) {
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var dataApi$1 = __importStar(dataApi);
exports.dataApi = dataApi$1;
var mediaApi$1 = __importStar(mediaApi);
exports.mediaApi = mediaApi$1;

exports.isExperienceEditorActive = util.isExperienceEditorActive;
exports.isServer = util.isServer;
exports.resetExperienceEditorChromes = util.resetExperienceEditorChromes;

exports.getFieldValue = layoutDataUtils.getFieldValue;
exports.getChildPlaceholder = layoutDataUtils.getChildPlaceholder;
});

unwrapExports(dist);
var dist_1 = dist.dataApi;
var dist_2 = dist.mediaApi;
var dist_3 = dist.isExperienceEditorActive;
var dist_4 = dist.isServer;
var dist_5 = dist.resetExperienceEditorChromes;
var dist_6 = dist.getFieldValue;
var dist_7 = dist.getChildPlaceholder;

const SITECORE = {};

class SitecoreContext {

    constructor() {
        this.componentFactory = null;
        this.context = {};
    }

    setComponentFactory(factory) {
        this.componentFactory = factory;
    }

    setSitecoreContext(properties) {
        this.context = properties;
    }
}

const getSitecoreContext = () => {
    const ctx = getContext(SITECORE);
    return ctx;
};

const setSitecoreContext = (ctx) => {
    setContext(SITECORE, ctx);
};

/* node_modules\jss-svelte\src\components\Placeholder.svelte generated by Svelte v3.9.1 */

const Placeholder = create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	

  let { name = "", rendering = null, store = null } = $$props;

  let renderingComponents = [];

  const getComponentForRendering = renderingDefinition => {
    const sitecoreContext = getSitecoreContext();
    let { componentFactory } = sitecoreContext;
    let component = componentFactory(renderingDefinition.componentName);
    return {
      uid: renderingDefinition.uid,
      renderingDefinition,
      component
    };
  };

  const getComponentsForRenderingData = (placeholderData) => {
    let components = placeholderData.map((rendering, index) => {
      let component = getComponentForRendering(rendering);
      renderingComponents.push(component);
    });
  };

  const constructPlaceholder = () => {
    while(renderingComponents.length > 0) {
      renderingComponents.pop();
    }

    const placeholders = rendering.placeholders;
    const currentPlaceholder = placeholders[name];

    getComponentsForRenderingData(currentPlaceholder);

    return true;
  };

	if ($$props.name === void 0 && $$bindings.name && name !== void 0) $$bindings.name(name);
	if ($$props.rendering === void 0 && $$bindings.rendering && rendering !== void 0) $$bindings.rendering(rendering);
	if ($$props.store === void 0 && $$bindings.store && store !== void 0) $$bindings.store(store);

	{
        rendering && constructPlaceholder();
      }

	return `${each(renderingComponents, (renderingComponent, i) => `${ renderingComponent.component ? `${validate_component(((renderingComponent.component) || missing_component), 'svelte:component').$$render($$result, {
		fields: renderingComponent.renderingDefinition.fields,
		rendering: renderingComponent.renderingDefinition,
		params: renderingComponent.renderingDefinition.params
	}, {}, {})}` : `<code${spread([renderingComponent.renderingDefinition.attributes])}>
	      ${renderingComponent.renderingDefinition.contents}
	    </code>` }`)}`;
});

/* src\Placeholders.svelte generated by Svelte v3.9.1 */

const css = {
	code: "section.svelte-xc6vo2{padding:20px;border-left:5px solid #ccc;margin-bottom:20px}",
	map: "{\"version\":3,\"file\":\"Placeholders.svelte\",\"sources\":[\"Placeholders.svelte\"],\"sourcesContent\":[\"<script>\\r\\n    import {Placeholder} from 'jss-svelte';\\r\\n\\r\\n    export let routeData = {};\\r\\n</script>\\r\\n\\r\\n<style>\\r\\n    section {\\r\\n        padding: 20px;\\r\\n        border-left: 5px solid #ccc;\\r\\n        margin-bottom: 20px;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n<section>\\r\\n    {#each Object.entries(routeData.placeholders) as placeholder}\\r\\n        {#if placeholder[1].length}\\r\\n            <h2>{placeholder[0]}</h2>\\r\\n            <Placeholder name={placeholder[0]} rendering={routeData} />\\r\\n        {/if}\\r\\n    {/each}\\r\\n</section>\"],\"names\":[],\"mappings\":\"AAOI,OAAO,cAAC,CAAC,AACL,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CAC3B,aAAa,CAAE,IAAI,AACvB,CAAC\"}"
};

const Placeholders = create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let { routeData = {} } = $$props;

	if ($$props.routeData === void 0 && $$bindings.routeData && routeData !== void 0) $$bindings.routeData(routeData);

	$$result.css.add(css);

	return `<section class="svelte-xc6vo2">
	    ${each(Object.entries(routeData.placeholders), (placeholder) => `${ placeholder[1].length ? `<h2>${escape(placeholder[0])}</h2>
	            ${validate_component(Placeholder, 'Placeholder').$$render($$result, {
		name: placeholder[0],
		rendering: routeData
	}, {}, {})}` : `` }`)}
	</section>`;
});

/* src\Fields.svelte generated by Svelte v3.9.1 */

const Fields = create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let { fields = {} } = $$props;

  const fieldEntries = Object.entries(fields);

  const getFieldType = fieldMarkup => {
      const result = fieldMarkup.match(/scfieldtype="(.*?)"/i);
    return (result && result[1]) || "n/a";
  };

	if ($$props.fields === void 0 && $$bindings.fields && fields !== void 0) $$bindings.fields(fields);

	return `${ fieldEntries.length ? `
	  <table class="table">
	    <thead>
	      <tr>
	        <th colspan="3">Fields</th>
	      </tr>
	    </thead>
	    ${each(fieldEntries, (field) => `${ field[1].editable ? `<tr>
	          <td>${escape(field[0])}</td>
	          <td>${escape(getFieldType(field[1].editable))}</td>
	          <td>
	            ${field[1].editable}
	          </td>
	        </tr>` : `` }`)}
	  </table>` : `` }`;
});

/* src\Component.svelte generated by Svelte v3.9.1 */

const Component = create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	
  let { rendering = {} } = $$props;

	if ($$props.rendering === void 0 && $$bindings.rendering && rendering !== void 0) $$bindings.rendering(rendering);

	return `<section>
	  <div>
	    <h4>${escape(rendering.componentName)} (${escape(rendering.componentName)})</h4>
	  </div>
	  <div>
	    ${validate_component(Fields, 'Fields').$$render($$result, { fields: rendering.fields }, {}, {})}
	  </div>
	  ${ rendering.placeholders ? `<div>
	      ${validate_component(Placeholders, 'Placeholders').$$render($$result, { routeData: rendering }, {}, {})}
	    </div>` : `` }
	</section>`;
});

function componentFactory(componentName) {
  return componentName ? Component : null;
}

/* src\App.svelte generated by Svelte v3.9.1 */

const App = create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	
  
  let { routeData = null } = $$props;

  const sitecoreContext = new SitecoreContext();
  sitecoreContext.setComponentFactory(componentFactory);
  setSitecoreContext(sitecoreContext);

	if ($$props.routeData === void 0 && $$bindings.routeData && routeData !== void 0) $$bindings.routeData(routeData);

	return `${validate_component(Placeholders, 'Placeholders').$$render($$result, { routeData: routeData.sitecore.route }, {}, {})}`;
});

function getIndexHtml() {
  let { html } = Index.render();
  return html;
}

function assertReplace(string, value, replacement) {
  let success = false;
  const result = string.replace(value, () => {
    success = true;
    return replacement;
  });

  if (!success) {
    throw new Error(
      `Unable to match replace token '${value}' in public/index.html template. If the HTML shell for the app is modified, also fix the replaces in server.js. Server-side rendering has failed!`
    );
  }

  return result;
}


function renderView(callback, path, data, viewBag) {
  const state = parseServerData(data, viewBag);

  let renderedApp = App.render({ path: path, routeData: state });

  const { html, css } = renderedApp;

  let indexHtml = getIndexHtml();

  indexHtml = assertReplace(
    indexHtml,
    '<div id="root"></div>',
    `<div id="root">${html}</div>`
  );

  indexHtml = assertReplace(
    indexHtml,
    '<style id="__SVELTE_CSS__"></style>',
    `<style id="__SVELTE_CSS__">${css.code}</style>`
  );

  callback(null, { html: indexHtml });
}

function parseServerData(data, viewBag) {
  const parsedData = data instanceof Object ? data : JSON.parse(data);
  const parsedViewBag = viewBag instanceof Object ? viewBag : JSON.parse(viewBag);

  return {
    viewBag: parsedViewBag,
    sitecore: parsedData && parsedData.sitecore,
  };
}

exports.renderView = renderView;
//# sourceMappingURL=server.bundle.js.map
